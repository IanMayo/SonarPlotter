<html>
<head>
	<style type="text/css">
		#container {
			width:500px;
			height:600px;
		}
	</style>
  <script type="text/javascript" src="js/jquery-1.11.0.min.js"></script>
  <script type="text/javascript" src="js/jquery.flot.js"></script>
  <script type="text/javascript" src="js/jquery.flot.time.js"></script>
  <script type="text/javascript" src="js/jquery.flot.navigate.js"></script>
  <script type="text/javascript" src="js/jquery.flot.fillbetween.js"></script>
  <script type="text/javascript" src="js/FastBlur.js"></script>

</head>
<body>

	<div id="container"></div>

	<script type="text/javascript">

      // Test data
      // Noise source should have a width parameter, so we represent it as a pair of series with different distance in each point. We'll fill this series between in order to achieve a monolithic form view.
      
      // helper array to find which series are paired
      var seriesPairs = [];
      var pair = ['ldata','rdata'];
      seriesPairs.push(pair);

      var data = [];
      var rdata = [];

      var t = new Date();
      for (var i = 0; i <= 100; i++) {
        var y = (t.getTime() + i * 3000);
        var x = 120+Math.random()*5;
        rdata.push([x+i*i/200+i/2, y]);
        data.push([x+20+i*i/200, y]);
      }

      // set initial top/bottom of plot
      var to = data[100][1]+2000;
      var bo = data[0][1]-6000;

      var options = {
        grid: {
        clickable: true,
        backgroundColor: '#26292B', 
      },
        hooks: { draw: [function(plot, canvascontext) { // Add a hook to fill the space between given series
                          fillseries(plot, canvascontext, 'ldata','rdata', false) //
                        }],
                 //bindEvents: [ClickPlot]
              },
         
        series: {
          color: '#269246',
          lines: {
            //clickable: true,
            //show: true,
            //lineWidth: 4.2
          },
          points: { show: false }
        },
        
        zoom: {
          interactive: true

        },

        xaxis: {
          min: 0,
          max: 360,
          //tickSize: 60,
          position: "top",
          zoomRange: [100, 360],// need to change to computable values to prevent stretch at zoom end
          panRange: false
        
        },
        
        yaxis: {
          max: to, // transfer initial top/bottom values
          min: bo,
          mode: "time",
          zoomRange: [60000,360000],// need to change to computable values to prevent stretch
          panRange: false,

          //format labels
          tickFormatter: function (v, axis) {
            var dat = new Date(v);
 
            //if (dat.getSeconds() % 20 == 0) {
                var h = dat.getHours() < 10 ? "0" + dat.getHours() : dat.getHours();
                var m = dat.getMinutes() < 10 ? "0" + dat.getMinutes() : dat.getMinutes();
                var s = dat.getSeconds() < 10 ? "0" + dat.getSeconds() : dat.getSeconds();
 
                return h + ":" + m + ":" + s;
            //} else {
            //    return "";
            //}
          }
        }
      };

      function fillseries(plot, canvascontext, idl, idr, selected){
        var ctx = canvascontext;

        var s, series, series1,
        i = 0,
        a = true;
        
        // Find series by names
        while (a) {

          s = plot.getData()[i];
          if (s == undefined) {
            //console.log('End of plot data');
            break;
          } else if (s.id == idl) {
            series = s;
            //console.log(s.id, ' found');
          }
          else if (s.id == idr) {
            series1 = s;
            //console.log(s.id, ' found');
            break;
          }
          
          i++;

        }

        if (series != null && series1 != null) {

          var points = series.datapoints.points,
              points1 = series1.datapoints.points;

          var xAxis = plot.getAxes().xaxis,
              yAxis = plot.getAxes().yaxis;

          var x,y;

          // Start drawing
          ctx.beginPath();

          // First series
          for (var i=0; i <= points.length; i++) {
          if (i%2 == 1)
            {
              x = points[i-1];
              y = points[i];
              ctx.lineTo(xAxis.p2c(x)+plot.offset().left-8,yAxis.p2c(y)+plot.offset().top-8);
            }
          }
          // Second series
          for (var i=points1.length; i >= 0; i--) {
          if (i%2 == 1)
            {
              x = points1[i-1];
              y = points1[i];
              ctx.lineTo(xAxis.p2c(x)+plot.offset().left-8,yAxis.p2c(y)+plot.offset().top-8);
            }
          }

          // Close path by moving to the initial point
          ctx.lineTo(xAxis.p2c(points[0]+plot.offset().left-8),yAxis.p2c(points[1])+plot.offset().top-8);
          //ctx.closePath();
          
          ctx.fillStyle = "rgba(124,229,82, 0.9)";

          // Add stroke to selected series
          if (selected) {
            ctx.lineWidth = 10;
            ctx.strokeStyle = "rgba(99,229,82, 0.2)";
            ctx.fill();
            ctx.stroke();
          }
          else ctx.fill(); 
          
          //var grd = ctx.createLinearGradient(0, 50, 0, 320);
          //grd.addColorStop(0, '#8BEE6F');
          //grd.addColorStop(1, "#438537");
          //ctx.stroke();
          //ctx.fillStyle = grd;

          // Close offset areas of previous fill which appears while graph zooming by white rectangles
          ctx.beginPath();
          ctx.rect(0,0,500,20);
          ctx.rect(0,594,500,6);
          ctx.fillStyle = 'white';
          ctx.fill(); 

        }
        else console.log('fillseries: not found');
   
      }


      // Click hook
      function ClickPlot(plot, eventHolder) {
          var xAxis = plot.getAxes().xaxis;
          var yAxis = plot.getAxes().yaxis;

          eventHolder.mousedown(function (e) {
            alert("You pressed the mouse at " + e.pageX + " " + e.pageY);
          });
      }


      // Make/draw plot
      var plot = $("#container").plot([
        {data: data, id: "ldata", lines:{fill:false}},
        {data: rdata, id: "rdata", lines:{fill:false}},
        ], options).data("plot");


      //Plot click event         
      $("#container").bind("plotclick", function (event, pos, item) {

        if (item){
          var series = item.series.id;
          //console.log(series.id);

          // Find pair of current series
          for (var i = 0; i <= seriesPairs.length; i++){
            if (seriesPairs[i][0] == series) {
              
              var series1 = seriesPairs[i][1];

              // Add hook to draw selection
              plot.getOptions().hooks.draw = [function(plot, canvascontext) { fillseries(plot, canvascontext,series,series1,true)}];
              
              // Redraw with selections
              var pOptions = plot.getOptions();
              plot = $.plot($("#container"), [{data: data, id: "ldata"},{data: rdata, id: "rdata"}], pOptions);
              break;
            }
            if (seriesPairs[i][1] == series) {

              var series1 = seriesPairs[i][0]; 

              // Add hook to draw selection
              plot.getOptions().hooks.draw = [function(plot, canvascontext) { fillseries(plot, canvascontext,series1,series,true)}];

              // Redraw with selections
              var pOptions = plot.getOptions();
              plot = $.plot($("#container"), [{data: data, id: "ldata"},{data: rdata, id: "rdata"}], pOptions);
              break;
            }
          }
        }

      });


      window.intervalId = setInterval(function() {
        var n = new Date();  // current time
        var y = n.getTime() + 100 * 3000; // time of new detections falling from the top

        // random test x data
        var x = 120+Math.random()*20;
        
        // add new point
        data.push([x, y]);
        rdata.push([x+20, y]);
        // remove last point to keep initial number of points
        data.splice(0, 1);
        rdata.splice(0, 1);
        
        // In order to move plot we need to increase it's borders in options
        plot.getOptions().yaxes[0].max += 3000;
        plot.getOptions().yaxes[0].min += 3000;
        plot.setupGrid();

        // get current axes
        var axes = plot.getAxes();
        
        // get current options without zoom modifications
        var pOptions = plot.getOptions();

        // set zoom modifications picked from the state of current axes
        pOptions.yaxis.max = axes.yaxis.max;
        pOptions.yaxis.min = axes.yaxis.min;
        //console.log(pOptions.yaxis.max);
        pOptions.xaxis.min = axes.xaxis.min;
        pOptions.xaxis.max = axes.xaxis.max;

        // draw new cadre, save plot object
        plot = $.plot($("#container"), [{data: data, id: "ldata"},{data: rdata, id: "rdata"}], pOptions);
        
        //$.extend(true, {}, options, {  yaxis: { min: axes.yaxis.min, max: axes.yaxis.max } })

       }, 3000);


	</script>
</body>
</html>